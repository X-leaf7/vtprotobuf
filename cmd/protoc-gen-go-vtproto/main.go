package main

import (
	"flag"
	"fmt"
	"runtime/debug"
	"strings"

	"vitess.io/vtprotobuf/vtproto"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

type ObjectSet map[protogen.GoIdent]bool

func (o ObjectSet) String() string {
	return fmt.Sprintf("%#v", o)
}

func (o ObjectSet) Set(s string) error {
	idx := strings.LastIndexByte(s, '.')
	if idx < 0 {
		return fmt.Errorf("invalid object name: %q", s)
	}

	ident := protogen.GoIdent{
		GoImportPath: protogen.GoImportPath(s[0:idx]),
		GoName:       s[idx+1:],
	}
	o[ident] = true
	return nil
}

func main() {
	poolable := make(ObjectSet)
	var f flag.FlagSet
	f.Var(poolable, "P", "use memory pooling for this object")
	protogen.Options{ParamFunc: f.Set}.Run(func(plugin *protogen.Plugin) error {
		generateAllFiles(plugin, poolable)
		return nil
	})
}

func generateAllFiles(plugin *protogen.Plugin, poolable ObjectSet) {
	seen := make(map[protogen.GoImportPath]bool)
	for _, file := range plugin.Files {
		if !file.Generate {
			continue
		}

		gf := plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+"_vtproto.pb.go", file.GoImportPath)
		if !generateFile(gf, file, seen) {
			gf.Skip()
		}
	}
}

var defaultPlugins []PluginFactory

func RegisterPlugin(plugin PluginFactory) {
	defaultPlugins = append(defaultPlugins, plugin)
}

type PluginFactory func(gen *VTGeneratedFile) Plugin

type Plugin interface {
	Name() string
	GenerateFile(file *protogen.File) bool
	GenerateHelpers()
}

type VTGeneratedFile struct {
	*protogen.GeneratedFile
}

func (p *VTGeneratedFile) Ident(path, ident string) string {
	return p.QualifiedGoIdent(protogen.GoImportPath(path).Ident(ident))
}

func (b *VTGeneratedFile) ShouldPool(message *protogen.Message) bool {
	if message == nil {
		return false
	}
	ext := proto.GetExtension(message.Desc.Options(), vtproto.E_Mempool)
	if mempool, ok := ext.(bool); ok {
		return mempool
	}
	return false
}

func generateFile(gen *protogen.GeneratedFile, file *protogen.File, seen map[protogen.GoImportPath]bool) bool {
	if file.Desc.Syntax() != protoreflect.Proto3 {
		return false
	}

	p := &VTGeneratedFile{
		GeneratedFile: gen,
	}

	p.P("// Code generated by protoc-gen-go-vtproto. DO NOT EDIT.")
	if bi, ok := debug.ReadBuildInfo(); ok {
		p.P("// protoc-gen-go-vtproto version: ", bi.Main.Version)
	}
	p.P("// source: ", file.Desc.Path())
	p.P()
	p.P("package ", file.GoPackageName)
	p.P()

	var generated bool
	for _, plugin := range defaultPlugins {
		np := plugin(p)
		if np.GenerateFile(file) {
			generated = true
			if !seen[file.GoImportPath] {
				np.GenerateHelpers()
			}
		}
	}

	seen[file.GoImportPath] = true
	return generated
}
