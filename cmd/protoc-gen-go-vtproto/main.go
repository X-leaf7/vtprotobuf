package main

import (
	"runtime/debug"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, f := range plugin.Files {
			if !f.Generate {
				continue
			}
			generateFile(plugin, f)
		}
		return nil
	})
}

func generateFile(plugin *protogen.Plugin, file *protogen.File) {
	gf := plugin.NewGeneratedFile(file.GeneratedFilenamePrefix+"_vtproto.pb.go", file.GoImportPath)
	vtprotogen := &vtproto{GeneratedFile: gf, stable: false}
	if !vtprotogen.Generate(file) {
		gf.Skip()
	}
}

type vtproto struct {
	*protogen.GeneratedFile
	atleastOne bool
	stable     bool
	localName  string
}

func (p *vtproto) generateMessage(message *protogen.Message) {
	for _, nested := range message.Messages {
		p.generateMessage(nested)
	}
	if message.Desc.IsMapEntry() {
		return
	}
	p.atleastOne = true
	p.generateMessageUnmarshal(message, true)
	p.generateMessageMarshal(message)
	p.generateMessageSize(message)
	p.generateMessagePool(message)
}

func (p *vtproto) Generate(file *protogen.File) bool {
	if file.Desc.Syntax() != protoreflect.Proto3 {
		return false
	}

	p.atleastOne = false
	p.localName = FileName(file)

	p.P("// Code generated by protoc-gen-go-vtproto. DO NOT EDIT.")
	if bi, ok := debug.ReadBuildInfo(); ok {
		p.P("// protoc-gen-go-vtproto version: ", bi.Main.Version)
	}
	p.P("// source: ", file.Desc.Path())
	p.P()
	p.P("package ", file.GoPackageName)
	p.P()

	for _, message := range file.Messages {
		p.generateMessage(message)
	}
	if !p.atleastOne {
		return false
	}
	p.generateUnmarshalHelpers()
	p.generateMarshalHelpers()
	p.generateSizeHelpers()

	p.P(`
	type vtprotoMessage`, p.localName, ` interface {
		MarshalToVT([]byte) (int, error)
		SizeVT() int
	}`)
	return true
}
